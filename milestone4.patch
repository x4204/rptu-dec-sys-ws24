--- core/node/libp2p/routing.go	2024-11-04 20:37:03.643408793 +0100
+++ core/node/libp2p/routing.go	2024-11-04 20:36:50.231182871 +0100
@@ -7,12 +7,9 @@
 	"sort"
 	"time"
 
-	"github.com/cenkalti/backoff/v4"
 	offroute "github.com/ipfs/boxo/routing/offline"
 	ds "github.com/ipfs/go-datastore"
-	dht "github.com/libp2p/go-libp2p-kad-dht"
 	ddht "github.com/libp2p/go-libp2p-kad-dht/dual"
-	"github.com/libp2p/go-libp2p-kad-dht/fullrt"
 	pubsub "github.com/libp2p/go-libp2p-pubsub"
 	namesys "github.com/libp2p/go-libp2p-pubsub-router"
 	record "github.com/libp2p/go-libp2p-record"
@@ -90,58 +87,6 @@
 			}
 		}
 
-		if dualDHT != nil && cfg.Routing.AcceleratedDHTClient.WithDefault(config.DefaultAcceleratedDHTClient) {
-			cfg, err := in.Repo.Config()
-			if err != nil {
-				return out, err
-			}
-			bspeers, err := cfg.BootstrapPeers()
-			if err != nil {
-				return out, err
-			}
-
-			fullRTClient, err := fullrt.NewFullRT(in.Host,
-				dht.DefaultPrefix,
-				fullrt.DHTOption(
-					dht.Validator(in.Validator),
-					dht.Datastore(in.Repo.Datastore()),
-					dht.BootstrapPeers(bspeers...),
-					dht.BucketSize(20),
-				),
-			)
-			if err != nil {
-				return out, err
-			}
-
-			lc.Append(fx.Hook{
-				OnStop: func(ctx context.Context) error {
-					return fullRTClient.Close()
-				},
-			})
-
-			// we want to also use the default HTTP routers, so wrap the FullRT client
-			// in a parallel router that calls them in parallel
-			httpRouters, err := constructDefaultHTTPRouters(cfg)
-			if err != nil {
-				return out, err
-			}
-			routers := []*routinghelpers.ParallelRouter{
-				{Router: fullRTClient, DoNotWaitForSearchValue: true},
-			}
-			routers = append(routers, httpRouters...)
-			router := routinghelpers.NewComposableParallel(routers)
-
-			return processInitialRoutingOut{
-				Router: Router{
-					Priority: 1000,
-					Routing:  router,
-				},
-				DHT:           dualDHT,
-				DHTClient:     fullRTClient,
-				ContentRouter: fullRTClient,
-			}, nil
-		}
-
 		return processInitialRoutingOut{
 			Router: Router{
 				Priority: 1000,
@@ -164,13 +109,6 @@
 // all together using a TieredRouter. It will be used for topic discovery.
 func ContentRouting(in p2pOnlineContentRoutingIn) routing.ContentRouting {
 	var routers []routing.Routing
-	for _, cr := range in.ContentRouter {
-		routers = append(routers,
-			&routinghelpers.Compose{
-				ContentRouting: cr,
-			},
-		)
-	}
 
 	return routinghelpers.Tiered{
 		Routers: routers,
@@ -195,6 +133,8 @@
 	})
 
 	var cRouters []*routinghelpers.ParallelRouter
+
+	// TODO: removing this causes a crash on `./ipfs init`
 	for _, v := range routers {
 		cRouters = append(cRouters, &routinghelpers.ParallelRouter{
 			IgnoreError:             true,
@@ -251,7 +191,7 @@
 
 func autoRelayFeeder(cfgPeering config.Peering, peerChan chan<- peer.AddrInfo) fx.Option {
 	return fx.Invoke(func(lc fx.Lifecycle, h host.Host, dht *ddht.DHT) {
-		ctx, cancel := context.WithCancel(context.Background())
+		_, cancel := context.WithCancel(context.Background())
 		done := make(chan struct{})
 
 		defer func() {
@@ -262,58 +202,6 @@
 		}()
 		go func() {
 			defer close(done)
-
-			// Feed peers more often right after the bootstrap, then backoff
-			bo := backoff.NewExponentialBackOff()
-			bo.InitialInterval = 15 * time.Second
-			bo.Multiplier = 3
-			bo.MaxInterval = 1 * time.Hour
-			bo.MaxElapsedTime = 0 // never stop
-			t := backoff.NewTicker(bo)
-			defer t.Stop()
-			for {
-				select {
-				case <-t.C:
-				case <-ctx.Done():
-					return
-				}
-
-				// Always feed trusted IDs (Peering.Peers in the config)
-				for _, trustedPeer := range cfgPeering.Peers {
-					if len(trustedPeer.Addrs) == 0 {
-						continue
-					}
-					select {
-					case peerChan <- trustedPeer:
-					case <-ctx.Done():
-						return
-					}
-				}
-
-				// Additionally, feed closest peers discovered via DHT
-				if dht == nil {
-					/* noop due to missing dht.WAN. happens in some unit tests,
-					   not worth fixing as we will refactor this after go-libp2p 0.20 */
-					continue
-				}
-				closestPeers, err := dht.WAN.GetClosestPeers(ctx, h.ID().String())
-				if err != nil {
-					// no-op: usually 'failed to find any peer in table' during startup
-					continue
-				}
-				for _, p := range closestPeers {
-					addrs := h.Peerstore().Addrs(p)
-					if len(addrs) == 0 {
-						continue
-					}
-					dhtPeer := peer.AddrInfo{ID: p, Addrs: addrs}
-					select {
-					case peerChan <- dhtPeer:
-					case <-ctx.Done():
-						return
-					}
-				}
-			}
 		}()
 
 		lc.Append(fx.Hook{
